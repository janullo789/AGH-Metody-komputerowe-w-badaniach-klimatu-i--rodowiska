library(raster)
library(rgeos)
library(gstat)
library(tmaptools)
for (i in seq(1,n_id)) {
print(i)
logic<-list_inst2[[i]]$current$values$name=="TEMPERATURE" #zmienna logiczna do wyszukania pól o nazwie "PM25"
if (sum(logic)==1) #testujemy, czy istnieje jedno i tylko jedno takie pole (zdarzają się błędne odczyty - tych nie chcemy zapisać)
current[i]<-list_inst2[[i]]$current$values[logic,2]
}
current
data15_spdf<-as.SpatialPointsDataFrame.ppp(data15_ppp_id)
coordinates(data15_spdf)
# dodajemy kolumnę current
data15_spdf$current<-current
dev.off() #bo może wariować RStudio
plot(data15_spdf)
miss <- is.na(data15_spdf$current)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,])
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(Window(data15_ppp_e),add=TRUE)
plot(pm25_auto)
#zmieńmy model i porównajmy wyniki, popatrzmy na wariogram
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,], model="Gau")
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(pm25_auto)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,],
model="Gau")
show.vgms()
show.vgms(models=c('Nug', 'Sph', 'Gau', 'Pow', 'Exp'), range=1.4,
max=2.5)
##ładna mapa
#Musimy mied kontur Krakowa w odpowiednim formacie:
bound<-st_as_sf(krakowUTM)
plot(bound)
#Pobieramy współrzędne punktów konturu w formie macierzy:
coord<-as.data.frame(st_coordinates(krakowUTM))
#Najpierw utworzymy siatkę - prostokąt okalający kontur Krakowa:
#1. Określamy współrzędne naroży
left_down<-c( min(coord$X), min(coord$Y))
right_up<-c( max(coord$X), max(coord$Y))
#2. Ustalamy rozmiar oczka siatki (100x100 metrów)
size<-c(100,100)
#3. Obliczamy liczbę oczek siatki przypadjących na długośd i szerokośd prostokąta:
points<- (right_up-left_down)/size
num_points<-ceiling(points) #zaokrąglenie w górę
#4. Wreszcie tworzymy siatkę…
grid <- GridTopology(left_down, size,num_points)
#5. …i konwertujemy ją do odpowiedniego formatu, w odpowiednim układzie (tu: WGS84)
gridpoints <- SpatialPoints(grid, proj4string = CRS("+proj=utm +zone=34
+datum=WGS84"))
plot(gridpoints) #czekamy cierpliwie
#Teraz przycinamy utworzoną siatkę konturem Krakowa funkcją crop_shape z pakietu tmaptools
g<-st_as_sf(gridpoints)#konwersja do formatu na którym działa crop_shape
cg<-crop_shape(g,bound,polygon = TRUE)
spgrid <- SpatialPixels(as_Spatial(cg)) #konwersja z powrotem do st i
#następnie do SpatialPixels
plot(spgrid)
#Rysujemy mape z wykorzystaniem krigingu:
##uwaga: ”current” zamiast ”marks”!
elev_auto <- autoKrige(current ~ 1, input_data =
data15_spdf[!miss,],new_data=spgrid)
plot(elev_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(elev_auto)
library(httr)
library(jsonlite)
library(utils)
library(sp)
library(sf)
library(spatstat)
library(maptools)
library(automap)
library(rgdal)
library(raster)
library(rgeos)
library(gstat)
library(tmaptools)
load(file="saves/list_instDzien1Rano.Rdata")
for (i in seq(1,n_id)) {
print(i)
logic<-list_inst2[[i]]$current$values$name=="TEMPERATURE" #zmienna logiczna do wyszukania pól o nazwie "PM25"
if (sum(logic)==1) #testujemy, czy istnieje jedno i tylko jedno takie pole (zdarzają się błędne odczyty - tych nie chcemy zapisać)
current[i]<-list_inst2[[i]]$current$values[logic,2]
}
current
data15_spdf<-as.SpatialPointsDataFrame.ppp(data15_ppp_id)
coordinates(data15_spdf)
# dodajemy kolumnę current
data15_spdf$current<-current
dev.off() #bo może wariować RStudio
plot(data15_spdf)
miss <- is.na(data15_spdf$current)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,])
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(Window(data15_ppp_e),add=TRUE)
plot(pm25_auto)
#zmieńmy model i porównajmy wyniki, popatrzmy na wariogram
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,], model="Gau")
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(pm25_auto)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,],
model="Gau")
show.vgms()
show.vgms(models=c('Nug', 'Sph', 'Gau', 'Pow', 'Exp'), range=1.4,
max=2.5)
##ładna mapa
#Musimy mied kontur Krakowa w odpowiednim formacie:
bound<-st_as_sf(krakowUTM)
plot(bound)
#Pobieramy współrzędne punktów konturu w formie macierzy:
coord<-as.data.frame(st_coordinates(krakowUTM))
#Najpierw utworzymy siatkę - prostokąt okalający kontur Krakowa:
#1. Określamy współrzędne naroży
left_down<-c( min(coord$X), min(coord$Y))
right_up<-c( max(coord$X), max(coord$Y))
#2. Ustalamy rozmiar oczka siatki (100x100 metrów)
size<-c(100,100)
#3. Obliczamy liczbę oczek siatki przypadjących na długośd i szerokośd prostokąta:
points<- (right_up-left_down)/size
num_points<-ceiling(points) #zaokrąglenie w górę
#4. Wreszcie tworzymy siatkę…
grid <- GridTopology(left_down, size,num_points)
#5. …i konwertujemy ją do odpowiedniego formatu, w odpowiednim układzie (tu: WGS84)
gridpoints <- SpatialPoints(grid, proj4string = CRS("+proj=utm +zone=34
+datum=WGS84"))
plot(gridpoints) #czekamy cierpliwie
#Teraz przycinamy utworzoną siatkę konturem Krakowa funkcją crop_shape z pakietu tmaptools
g<-st_as_sf(gridpoints)#konwersja do formatu na którym działa crop_shape
cg<-crop_shape(g,bound,polygon = TRUE)
spgrid <- SpatialPixels(as_Spatial(cg)) #konwersja z powrotem do st i
#następnie do SpatialPixels
plot(spgrid)
#Rysujemy mape z wykorzystaniem krigingu:
##uwaga: ”current” zamiast ”marks”!
elev_auto <- autoKrige(current ~ 1, input_data =
data15_spdf[!miss,],new_data=spgrid)
plot(elev_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(elev_auto)
load(file="saves/list_instDzien1Poludnie.Rdata")
#Musimy mied kontur Krakowa w odpowiednim formacie:
bound<-st_as_sf(krakowUTM)
plot(bound)
#Pobieramy współrzędne punktów konturu w formie macierzy:
coord<-as.data.frame(st_coordinates(krakowUTM))
#Najpierw utworzymy siatkę - prostokąt okalający kontur Krakowa:
#1. Określamy współrzędne naroży
left_down<-c( min(coord$X), min(coord$Y))
right_up<-c( max(coord$X), max(coord$Y))
#2. Ustalamy rozmiar oczka siatki (100x100 metrów)
size<-c(100,100)
#3. Obliczamy liczbę oczek siatki przypadjących na długośd i szerokośd prostokąta:
points<- (right_up-left_down)/size
num_points<-ceiling(points) #zaokrąglenie w górę
#4. Wreszcie tworzymy siatkę…
grid <- GridTopology(left_down, size,num_points)
#5. …i konwertujemy ją do odpowiedniego formatu, w odpowiednim układzie (tu: WGS84)
gridpoints <- SpatialPoints(grid, proj4string = CRS("+proj=utm +zone=34
+datum=WGS84"))
plot(gridpoints) #czekamy cierpliwie
#Teraz przycinamy utworzoną siatkę konturem Krakowa funkcją crop_shape z pakietu tmaptools
g<-st_as_sf(gridpoints)#konwersja do formatu na którym działa crop_shape
cg<-crop_shape(g,bound,polygon = TRUE)
spgrid <- SpatialPixels(as_Spatial(cg)) #konwersja z powrotem do st i
#następnie do SpatialPixels
plot(spgrid)
#Rysujemy mape z wykorzystaniem krigingu:
##uwaga: ”current” zamiast ”marks”!
elev_auto <- autoKrige(current ~ 1, input_data =
data15_spdf[!miss,],new_data=spgrid)
plot(elev_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(elev_auto)
list_inst2<-list_instDzien1Rano #tutaj tez zmieniamy zmienną
current<-rep(NA,n_id)
for (i in seq(1,n_id)) {
print(i)
logic<-list_inst2[[i]]$current$values$name=="TEMPERATURE" #zmienna logiczna do wyszukania pól o nazwie "PM25"
if (sum(logic)==1) #testujemy, czy istnieje jedno i tylko jedno takie pole (zdarzają się błędne odczyty - tych nie chcemy zapisać)
current[i]<-list_inst2[[i]]$current$values[logic,2]
}
current
data15_spdf<-as.SpatialPointsDataFrame.ppp(data15_ppp_id)
coordinates(data15_spdf)
# dodajemy kolumnę current
data15_spdf$current<-current
dev.off() #bo może wariować RStudio
plot(data15_spdf)
miss <- is.na(data15_spdf$current)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,])
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(Window(data15_ppp_e),add=TRUE)
plot(pm25_auto)
#zmieńmy model i porównajmy wyniki, popatrzmy na wariogram
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,], model="Gau")
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(pm25_auto)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,],
model="Gau")
show.vgms()
show.vgms(models=c('Nug', 'Sph', 'Gau', 'Pow', 'Exp'), range=1.4,
max=2.5)
##ładna mapa
#Musimy mied kontur Krakowa w odpowiednim formacie:
bound<-st_as_sf(krakowUTM)
plot(bound)
#Pobieramy współrzędne punktów konturu w formie macierzy:
coord<-as.data.frame(st_coordinates(krakowUTM))
#Najpierw utworzymy siatkę - prostokąt okalający kontur Krakowa:
#1. Określamy współrzędne naroży
left_down<-c( min(coord$X), min(coord$Y))
right_up<-c( max(coord$X), max(coord$Y))
#2. Ustalamy rozmiar oczka siatki (100x100 metrów)
size<-c(100,100)
#3. Obliczamy liczbę oczek siatki przypadjących na długośd i szerokośd prostokąta:
points<- (right_up-left_down)/size
num_points<-ceiling(points) #zaokrąglenie w górę
#4. Wreszcie tworzymy siatkę…
grid <- GridTopology(left_down, size,num_points)
#5. …i konwertujemy ją do odpowiedniego formatu, w odpowiednim układzie (tu: WGS84)
gridpoints <- SpatialPoints(grid, proj4string = CRS("+proj=utm +zone=34
+datum=WGS84"))
plot(gridpoints) #czekamy cierpliwie
#Teraz przycinamy utworzoną siatkę konturem Krakowa funkcją crop_shape z pakietu tmaptools
g<-st_as_sf(gridpoints)#konwersja do formatu na którym działa crop_shape
cg<-crop_shape(g,bound,polygon = TRUE)
spgrid <- SpatialPixels(as_Spatial(cg)) #konwersja z powrotem do st i
#następnie do SpatialPixels
plot(spgrid)
#Rysujemy mape z wykorzystaniem krigingu:
##uwaga: ”current” zamiast ”marks”!
elev_auto <- autoKrige(current ~ 1, input_data =
data15_spdf[!miss,],new_data=spgrid)
plot(elev_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(elev_auto)
list_inst2<-list_instDzien1Poludnie #tutaj tez zmieniamy zmienną
#teraz wybieramy potrzebne dane
##tworzymy pusty wektor dla danych "current"
current<-rep(NA,n_id)
###### temperatura (skopiowane co jest wyzej z podmienionymi danymi)
for (i in seq(1,n_id)) {
print(i)
logic<-list_inst2[[i]]$current$values$name=="TEMPERATURE" #zmienna logiczna do wyszukania pól o nazwie "PM25"
if (sum(logic)==1) #testujemy, czy istnieje jedno i tylko jedno takie pole (zdarzają się błędne odczyty - tych nie chcemy zapisać)
current[i]<-list_inst2[[i]]$current$values[logic,2]
}
current
data15_spdf<-as.SpatialPointsDataFrame.ppp(data15_ppp_id)
coordinates(data15_spdf)
# dodajemy kolumnę current
data15_spdf$current<-current
dev.off() #bo może wariować RStudio
plot(data15_spdf)
miss <- is.na(data15_spdf$current)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,])
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(Window(data15_ppp_e),add=TRUE)
plot(pm25_auto)
#zmieńmy model i porównajmy wyniki, popatrzmy na wariogram
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,], model="Gau")
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(pm25_auto)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,],
model="Gau")
show.vgms()
show.vgms(models=c('Nug', 'Sph', 'Gau', 'Pow', 'Exp'), range=1.4,
max=2.5)
##ładna mapa
#Musimy mied kontur Krakowa w odpowiednim formacie:
bound<-st_as_sf(krakowUTM)
plot(bound)
#Pobieramy współrzędne punktów konturu w formie macierzy:
coord<-as.data.frame(st_coordinates(krakowUTM))
#Najpierw utworzymy siatkę - prostokąt okalający kontur Krakowa:
#1. Określamy współrzędne naroży
left_down<-c( min(coord$X), min(coord$Y))
right_up<-c( max(coord$X), max(coord$Y))
#2. Ustalamy rozmiar oczka siatki (100x100 metrów)
size<-c(100,100)
#3. Obliczamy liczbę oczek siatki przypadjących na długośd i szerokośd prostokąta:
points<- (right_up-left_down)/size
num_points<-ceiling(points) #zaokrąglenie w górę
#4. Wreszcie tworzymy siatkę…
grid <- GridTopology(left_down, size,num_points)
#5. …i konwertujemy ją do odpowiedniego formatu, w odpowiednim układzie (tu: WGS84)
gridpoints <- SpatialPoints(grid, proj4string = CRS("+proj=utm +zone=34
+datum=WGS84"))
plot(gridpoints) #czekamy cierpliwie
#Teraz przycinamy utworzoną siatkę konturem Krakowa funkcją crop_shape z pakietu tmaptools
g<-st_as_sf(gridpoints)#konwersja do formatu na którym działa crop_shape
cg<-crop_shape(g,bound,polygon = TRUE)
spgrid <- SpatialPixels(as_Spatial(cg)) #konwersja z powrotem do st i
#następnie do SpatialPixels
plot(spgrid)
#Rysujemy mape z wykorzystaniem krigingu:
##uwaga: ”current” zamiast ”marks”!
elev_auto <- autoKrige(current ~ 1, input_data =
data15_spdf[!miss,],new_data=spgrid)
plot(elev_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(elev_auto)
load(file="saves/list_instDzien1Wieczor.Rdata")
list_inst2<-list_instDzien1Wieczor #tutaj tez zmieniamy zmienną
current<-rep(NA,n_id)
##pętla do "wyciągnięcia" wartości "current"
for (i in seq(1,n_id)) {
print(i)
logic<-list_inst2[[i]]$current$values$name=="PM25" #zmienna logiczna do wyszukania pól o nazwie "PM25"
if (sum(logic)==1) #testujemy, czy istnieje jedno i tylko jedno takie pole (zdarzają się błędne odczyty - tych nie chcemy zapisać)
current[i]<-list_inst2[[i]]$current$values[logic,2]
}
current
data15_spdf<-as.SpatialPointsDataFrame.ppp(data15_ppp_id)
coordinates(data15_spdf)
# dodajemy kolumnę current
data15_spdf$current<-current
dev.off() #bo może wariować RStudio
plot(data15_spdf)
miss <- is.na(data15_spdf$current)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,])
plot(pm25_auto$krige_output[1],main="PM 2.5")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(Window(data15_ppp_e),add=TRUE)
plot(pm25_auto)
#zmieńmy model i porównajmy wyniki, popatrzmy na wariogram
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,], model="Gau")
plot(pm25_auto$krige_output[1],main="PM 2.5")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(pm25_auto)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,],
model="Gau")
show.vgms()
show.vgms(models=c('Nug', 'Sph', 'Gau', 'Pow', 'Exp'), range=1.4,
max=2.5)
##ładna mapa
#Musimy mied kontur Krakowa w odpowiednim formacie:
bound<-st_as_sf(krakowUTM)
plot(bound)
#Pobieramy współrzędne punktów konturu w formie macierzy:
coord<-as.data.frame(st_coordinates(krakowUTM))
#Najpierw utworzymy siatkę - prostokąt okalający kontur Krakowa:
#1. Określamy współrzędne naroży
left_down<-c( min(coord$X), min(coord$Y))
right_up<-c( max(coord$X), max(coord$Y))
#2. Ustalamy rozmiar oczka siatki (100x100 metrów)
size<-c(100,100)
#3. Obliczamy liczbę oczek siatki przypadjących na długośd i szerokośd prostokąta:
points<- (right_up-left_down)/size
num_points<-ceiling(points) #zaokrąglenie w górę
#4. Wreszcie tworzymy siatkę…
grid <- GridTopology(left_down, size,num_points)
#5. …i konwertujemy ją do odpowiedniego formatu, w odpowiednim układzie (tu: WGS84)
gridpoints <- SpatialPoints(grid, proj4string = CRS("+proj=utm +zone=34
+datum=WGS84"))
plot(gridpoints) #czekamy cierpliwie
#Teraz przycinamy utworzoną siatkę konturem Krakowa funkcją crop_shape z pakietu tmaptools
g<-st_as_sf(gridpoints)#konwersja do formatu na którym działa crop_shape
cg<-crop_shape(g,bound,polygon = TRUE)
spgrid <- SpatialPixels(as_Spatial(cg)) #konwersja z powrotem do st i
#następnie do SpatialPixels
plot(spgrid)
#Rysujemy mape z wykorzystaniem krigingu:
##uwaga: ”current” zamiast ”marks”!
elev_auto <- autoKrige(current ~ 1, input_data =
data15_spdf[!miss,],new_data=spgrid)
plot(elev_auto$krige_output[1],main="PM 2.5")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(elev_auto)
load(file="saves/list_instDzien2Rano.Rdata")
list_inst2<-list_instDzien2Rano #tutaj tez zmieniamy zmienną
#teraz wybieramy potrzebne dane
##tworzymy pusty wektor dla danych "current"
current<-rep(NA,n_id)
##pętla do "wyciągnięcia" wartości "current"
for (i in seq(1,n_id)) {
print(i)
logic<-list_inst2[[i]]$current$values$name=="PM25" #zmienna logiczna do wyszukania pól o nazwie "PM25"
if (sum(logic)==1) #testujemy, czy istnieje jedno i tylko jedno takie pole (zdarzają się błędne odczyty - tych nie chcemy zapisać)
current[i]<-list_inst2[[i]]$current$values[logic,2]
}
current
data15_spdf<-as.SpatialPointsDataFrame.ppp(data15_ppp_id)
coordinates(data15_spdf)
# dodajemy kolumnę current
data15_spdf$current<-current
dev.off() #bo może wariować RStudio
plot(data15_spdf)
miss <- is.na(data15_spdf$current)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,])
plot(pm25_auto$krige_output[1],main="PM 2.5")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(Window(data15_ppp_e),add=TRUE)
plot(pm25_auto)
#zmieńmy model i porównajmy wyniki, popatrzmy na wariogram
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,], model="Gau")
plot(pm25_auto$krige_output[1],main="PM 2.5")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(pm25_auto)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,],
model="Gau")
show.vgms()
show.vgms(models=c('Nug', 'Sph', 'Gau', 'Pow', 'Exp'), range=1.4,
max=2.5)
##ładna mapa
#Musimy mied kontur Krakowa w odpowiednim formacie:
bound<-st_as_sf(krakowUTM)
plot(bound)
#Pobieramy współrzędne punktów konturu w formie macierzy:
coord<-as.data.frame(st_coordinates(krakowUTM))
#Najpierw utworzymy siatkę - prostokąt okalający kontur Krakowa:
#1. Określamy współrzędne naroży
left_down<-c( min(coord$X), min(coord$Y))
right_up<-c( max(coord$X), max(coord$Y))
#2. Ustalamy rozmiar oczka siatki (100x100 metrów)
size<-c(100,100)
#3. Obliczamy liczbę oczek siatki przypadjących na długośd i szerokośd prostokąta:
points<- (right_up-left_down)/size
num_points<-ceiling(points) #zaokrąglenie w górę
#4. Wreszcie tworzymy siatkę…
grid <- GridTopology(left_down, size,num_points)
#5. …i konwertujemy ją do odpowiedniego formatu, w odpowiednim układzie (tu: WGS84)
gridpoints <- SpatialPoints(grid, proj4string = CRS("+proj=utm +zone=34
+datum=WGS84"))
plot(gridpoints) #czekamy cierpliwie
#Teraz przycinamy utworzoną siatkę konturem Krakowa funkcją crop_shape z pakietu tmaptools
g<-st_as_sf(gridpoints)#konwersja do formatu na którym działa crop_shape
cg<-crop_shape(g,bound,polygon = TRUE)
spgrid <- SpatialPixels(as_Spatial(cg)) #konwersja z powrotem do st i
#następnie do SpatialPixels
plot(spgrid)
#Rysujemy mape z wykorzystaniem krigingu:
##uwaga: ”current” zamiast ”marks”!
elev_auto <- autoKrige(current ~ 1, input_data =
data15_spdf[!miss,],new_data=spgrid)
plot(elev_auto$krige_output[1],main="PM 2.5")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(elev_auto)
###### temperatura (skopiowane co jest wyzej z podmienionymi danymi)
for (i in seq(1,n_id)) {
print(i)
logic<-list_inst2[[i]]$current$values$name=="TEMPERATURE" #zmienna logiczna do wyszukania pól o nazwie "PM25"
if (sum(logic)==1) #testujemy, czy istnieje jedno i tylko jedno takie pole (zdarzają się błędne odczyty - tych nie chcemy zapisać)
current[i]<-list_inst2[[i]]$current$values[logic,2]
}
current
data15_spdf<-as.SpatialPointsDataFrame.ppp(data15_ppp_id)
coordinates(data15_spdf)
# dodajemy kolumnę current
data15_spdf$current<-current
dev.off() #bo może wariować RStudio
plot(data15_spdf)
miss <- is.na(data15_spdf$current)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,])
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(Window(data15_ppp_e),add=TRUE)
plot(pm25_auto)
#zmieńmy model i porównajmy wyniki, popatrzmy na wariogram
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,], model="Gau")
plot(pm25_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(pm25_auto)
pm25_auto <- autoKrige(current ~ 1, input_data = data15_spdf[!miss,],
model="Gau")
show.vgms()
show.vgms(models=c('Nug', 'Sph', 'Gau', 'Pow', 'Exp'), range=1.4,
max=2.5)
##ładna mapa
#Musimy mied kontur Krakowa w odpowiednim formacie:
bound<-st_as_sf(krakowUTM)
plot(bound)
#Pobieramy współrzędne punktów konturu w formie macierzy:
coord<-as.data.frame(st_coordinates(krakowUTM))
#Najpierw utworzymy siatkę - prostokąt okalający kontur Krakowa:
#1. Określamy współrzędne naroży
left_down<-c( min(coord$X), min(coord$Y))
right_up<-c( max(coord$X), max(coord$Y))
#2. Ustalamy rozmiar oczka siatki (100x100 metrów)
size<-c(100,100)
#3. Obliczamy liczbę oczek siatki przypadjących na długośd i szerokośd prostokąta:
points<- (right_up-left_down)/size
num_points<-ceiling(points) #zaokrąglenie w górę
#4. Wreszcie tworzymy siatkę…
grid <- GridTopology(left_down, size,num_points)
#5. …i konwertujemy ją do odpowiedniego formatu, w odpowiednim układzie (tu: WGS84)
gridpoints <- SpatialPoints(grid, proj4string = CRS("+proj=utm +zone=34
+datum=WGS84"))
plot(gridpoints) #czekamy cierpliwie
#Teraz przycinamy utworzoną siatkę konturem Krakowa funkcją crop_shape z pakietu tmaptools
g<-st_as_sf(gridpoints)#konwersja do formatu na którym działa crop_shape
cg<-crop_shape(g,bound,polygon = TRUE)
spgrid <- SpatialPixels(as_Spatial(cg)) #konwersja z powrotem do st i
#następnie do SpatialPixels
plot(spgrid)
#Rysujemy mape z wykorzystaniem krigingu:
##uwaga: ”current” zamiast ”marks”!
elev_auto <- autoKrige(current ~ 1, input_data =
data15_spdf[!miss,],new_data=spgrid)
plot(elev_auto$krige_output[1],main="TEMP")
points(data15_ppp_id[!miss,],pch="*",col="White")
plot(elev_auto)
View(list_instDzien2Rano)
